// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: audit_log.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const countAuditLogsByEntity = `-- name: CountAuditLogsByEntity :one
SELECT COUNT(*) FROM audit_logs
WHERE entity_type = $1 AND entity_id = $2
`

type CountAuditLogsByEntityParams struct {
	EntityType string      `json:"entity_type"`
	EntityID   pgtype.UUID `json:"entity_id"`
}

func (q *Queries) CountAuditLogsByEntity(ctx context.Context, arg CountAuditLogsByEntityParams) (int64, error) {
	row := q.db.QueryRow(ctx, countAuditLogsByEntity, arg.EntityType, arg.EntityID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countAuditLogsByUser = `-- name: CountAuditLogsByUser :one
SELECT COUNT(*) FROM audit_logs
WHERE user_id = $1
`

func (q *Queries) CountAuditLogsByUser(ctx context.Context, userID pgtype.UUID) (int64, error) {
	row := q.db.QueryRow(ctx, countAuditLogsByUser, userID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createAuditLog = `-- name: CreateAuditLog :one
INSERT INTO audit_logs (
    user_id,
    action,
    entity_type,
    entity_id,
    old_data,
    new_data,
    request_id,
    ip_address,
    user_agent,
    metadata,
    created_at
) VALUES (
    $1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11
) RETURNING id, user_id, action, entity_type, entity_id, old_data, new_data, request_id, ip_address, user_agent, metadata, created_at
`

type CreateAuditLogParams struct {
	UserID     pgtype.UUID        `json:"user_id"`
	Action     AuditAction        `json:"action"`
	EntityType string             `json:"entity_type"`
	EntityID   pgtype.UUID        `json:"entity_id"`
	OldData    []byte             `json:"old_data"`
	NewData    []byte             `json:"new_data"`
	RequestID  pgtype.Text        `json:"request_id"`
	IpAddress  pgtype.Text        `json:"ip_address"`
	UserAgent  pgtype.Text        `json:"user_agent"`
	Metadata   []byte             `json:"metadata"`
	CreatedAt  pgtype.Timestamptz `json:"created_at"`
}

func (q *Queries) CreateAuditLog(ctx context.Context, arg CreateAuditLogParams) (AuditLog, error) {
	row := q.db.QueryRow(ctx, createAuditLog,
		arg.UserID,
		arg.Action,
		arg.EntityType,
		arg.EntityID,
		arg.OldData,
		arg.NewData,
		arg.RequestID,
		arg.IpAddress,
		arg.UserAgent,
		arg.Metadata,
		arg.CreatedAt,
	)
	var i AuditLog
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Action,
		&i.EntityType,
		&i.EntityID,
		&i.OldData,
		&i.NewData,
		&i.RequestID,
		&i.IpAddress,
		&i.UserAgent,
		&i.Metadata,
		&i.CreatedAt,
	)
	return i, err
}

const getAuditLogByID = `-- name: GetAuditLogByID :one
SELECT id, user_id, action, entity_type, entity_id, old_data, new_data, request_id, ip_address, user_agent, metadata, created_at FROM audit_logs
WHERE id = $1 LIMIT 1
`

func (q *Queries) GetAuditLogByID(ctx context.Context, id pgtype.UUID) (AuditLog, error) {
	row := q.db.QueryRow(ctx, getAuditLogByID, id)
	var i AuditLog
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Action,
		&i.EntityType,
		&i.EntityID,
		&i.OldData,
		&i.NewData,
		&i.RequestID,
		&i.IpAddress,
		&i.UserAgent,
		&i.Metadata,
		&i.CreatedAt,
	)
	return i, err
}

const listAuditLogsByDateRange = `-- name: ListAuditLogsByDateRange :many
SELECT id, user_id, action, entity_type, entity_id, old_data, new_data, request_id, ip_address, user_agent, metadata, created_at FROM audit_logs
WHERE created_at >= $1 AND created_at < $2
ORDER BY created_at DESC
LIMIT $3 OFFSET $4
`

type ListAuditLogsByDateRangeParams struct {
	CreatedAt   pgtype.Timestamptz `json:"created_at"`
	CreatedAt_2 pgtype.Timestamptz `json:"created_at_2"`
	Limit       int64              `json:"limit"`
	Offset      int64              `json:"offset"`
}

func (q *Queries) ListAuditLogsByDateRange(ctx context.Context, arg ListAuditLogsByDateRangeParams) ([]AuditLog, error) {
	rows, err := q.db.Query(ctx, listAuditLogsByDateRange,
		arg.CreatedAt,
		arg.CreatedAt_2,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []AuditLog{}
	for rows.Next() {
		var i AuditLog
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.Action,
			&i.EntityType,
			&i.EntityID,
			&i.OldData,
			&i.NewData,
			&i.RequestID,
			&i.IpAddress,
			&i.UserAgent,
			&i.Metadata,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listAuditLogsByEntity = `-- name: ListAuditLogsByEntity :many
SELECT id, user_id, action, entity_type, entity_id, old_data, new_data, request_id, ip_address, user_agent, metadata, created_at FROM audit_logs
WHERE entity_type = $1 AND entity_id = $2
ORDER BY created_at DESC
LIMIT $3 OFFSET $4
`

type ListAuditLogsByEntityParams struct {
	EntityType string      `json:"entity_type"`
	EntityID   pgtype.UUID `json:"entity_id"`
	Limit      int64       `json:"limit"`
	Offset     int64       `json:"offset"`
}

func (q *Queries) ListAuditLogsByEntity(ctx context.Context, arg ListAuditLogsByEntityParams) ([]AuditLog, error) {
	rows, err := q.db.Query(ctx, listAuditLogsByEntity,
		arg.EntityType,
		arg.EntityID,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []AuditLog{}
	for rows.Next() {
		var i AuditLog
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.Action,
			&i.EntityType,
			&i.EntityID,
			&i.OldData,
			&i.NewData,
			&i.RequestID,
			&i.IpAddress,
			&i.UserAgent,
			&i.Metadata,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listAuditLogsByEntityAndDateRange = `-- name: ListAuditLogsByEntityAndDateRange :many
SELECT id, user_id, action, entity_type, entity_id, old_data, new_data, request_id, ip_address, user_agent, metadata, created_at FROM audit_logs
WHERE entity_type = $1 
  AND entity_id = $2
  AND created_at >= $3 
  AND created_at < $4
ORDER BY created_at DESC
LIMIT $5 OFFSET $6
`

type ListAuditLogsByEntityAndDateRangeParams struct {
	EntityType  string             `json:"entity_type"`
	EntityID    pgtype.UUID        `json:"entity_id"`
	CreatedAt   pgtype.Timestamptz `json:"created_at"`
	CreatedAt_2 pgtype.Timestamptz `json:"created_at_2"`
	Limit       int64              `json:"limit"`
	Offset      int64              `json:"offset"`
}

func (q *Queries) ListAuditLogsByEntityAndDateRange(ctx context.Context, arg ListAuditLogsByEntityAndDateRangeParams) ([]AuditLog, error) {
	rows, err := q.db.Query(ctx, listAuditLogsByEntityAndDateRange,
		arg.EntityType,
		arg.EntityID,
		arg.CreatedAt,
		arg.CreatedAt_2,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []AuditLog{}
	for rows.Next() {
		var i AuditLog
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.Action,
			&i.EntityType,
			&i.EntityID,
			&i.OldData,
			&i.NewData,
			&i.RequestID,
			&i.IpAddress,
			&i.UserAgent,
			&i.Metadata,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listAuditLogsByEntityType = `-- name: ListAuditLogsByEntityType :many
SELECT id, user_id, action, entity_type, entity_id, old_data, new_data, request_id, ip_address, user_agent, metadata, created_at FROM audit_logs
WHERE entity_type = $1
ORDER BY created_at DESC
LIMIT $2 OFFSET $3
`

type ListAuditLogsByEntityTypeParams struct {
	EntityType string `json:"entity_type"`
	Limit      int64  `json:"limit"`
	Offset     int64  `json:"offset"`
}

func (q *Queries) ListAuditLogsByEntityType(ctx context.Context, arg ListAuditLogsByEntityTypeParams) ([]AuditLog, error) {
	rows, err := q.db.Query(ctx, listAuditLogsByEntityType, arg.EntityType, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []AuditLog{}
	for rows.Next() {
		var i AuditLog
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.Action,
			&i.EntityType,
			&i.EntityID,
			&i.OldData,
			&i.NewData,
			&i.RequestID,
			&i.IpAddress,
			&i.UserAgent,
			&i.Metadata,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listAuditLogsByRequestID = `-- name: ListAuditLogsByRequestID :many
SELECT id, user_id, action, entity_type, entity_id, old_data, new_data, request_id, ip_address, user_agent, metadata, created_at FROM audit_logs
WHERE request_id = $1
ORDER BY created_at ASC
`

func (q *Queries) ListAuditLogsByRequestID(ctx context.Context, requestID pgtype.Text) ([]AuditLog, error) {
	rows, err := q.db.Query(ctx, listAuditLogsByRequestID, requestID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []AuditLog{}
	for rows.Next() {
		var i AuditLog
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.Action,
			&i.EntityType,
			&i.EntityID,
			&i.OldData,
			&i.NewData,
			&i.RequestID,
			&i.IpAddress,
			&i.UserAgent,
			&i.Metadata,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listAuditLogsByUser = `-- name: ListAuditLogsByUser :many
SELECT id, user_id, action, entity_type, entity_id, old_data, new_data, request_id, ip_address, user_agent, metadata, created_at FROM audit_logs
WHERE user_id = $1
ORDER BY created_at DESC
LIMIT $2 OFFSET $3
`

type ListAuditLogsByUserParams struct {
	UserID pgtype.UUID `json:"user_id"`
	Limit  int64       `json:"limit"`
	Offset int64       `json:"offset"`
}

func (q *Queries) ListAuditLogsByUser(ctx context.Context, arg ListAuditLogsByUserParams) ([]AuditLog, error) {
	rows, err := q.db.Query(ctx, listAuditLogsByUser, arg.UserID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []AuditLog{}
	for rows.Next() {
		var i AuditLog
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.Action,
			&i.EntityType,
			&i.EntityID,
			&i.OldData,
			&i.NewData,
			&i.RequestID,
			&i.IpAddress,
			&i.UserAgent,
			&i.Metadata,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
