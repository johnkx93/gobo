// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: address.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const clearDefaultAddress = `-- name: ClearDefaultAddress :one
UPDATE users
SET default_address_id = NULL
WHERE id = $1
RETURNING id, email, username, password_hash, first_name, last_name, created_at, updated_at, default_address_id
`

func (q *Queries) ClearDefaultAddress(ctx context.Context, id pgtype.UUID) (User, error) {
	row := q.db.QueryRow(ctx, clearDefaultAddress, id)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Email,
		&i.Username,
		&i.PasswordHash,
		&i.FirstName,
		&i.LastName,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DefaultAddressID,
	)
	return i, err
}

const countAddresses = `-- name: CountAddresses :one
SELECT COUNT(*) FROM addresses
`

func (q *Queries) CountAddresses(ctx context.Context) (int64, error) {
	row := q.db.QueryRow(ctx, countAddresses)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countAddressesByUserID = `-- name: CountAddressesByUserID :one
SELECT COUNT(*) FROM addresses
WHERE user_id = $1
`

func (q *Queries) CountAddressesByUserID(ctx context.Context, userID pgtype.UUID) (int64, error) {
	row := q.db.QueryRow(ctx, countAddressesByUserID, userID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createAddress = `-- name: CreateAddress :one
INSERT INTO addresses (
    user_id,
    address,
    floor,
    unit_no,
    block_tower,
    company_name
) VALUES (
    $1, $2, $3, $4, $5, $6
) RETURNING id, user_id, address, floor, unit_no, block_tower, company_name, created_at, updated_at
`

type CreateAddressParams struct {
	UserID      pgtype.UUID `json:"user_id"`
	Address     string      `json:"address"`
	Floor       string      `json:"floor"`
	UnitNo      string      `json:"unit_no"`
	BlockTower  pgtype.Text `json:"block_tower"`
	CompanyName pgtype.Text `json:"company_name"`
}

func (q *Queries) CreateAddress(ctx context.Context, arg CreateAddressParams) (Address, error) {
	row := q.db.QueryRow(ctx, createAddress,
		arg.UserID,
		arg.Address,
		arg.Floor,
		arg.UnitNo,
		arg.BlockTower,
		arg.CompanyName,
	)
	var i Address
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Address,
		&i.Floor,
		&i.UnitNo,
		&i.BlockTower,
		&i.CompanyName,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const deleteAddress = `-- name: DeleteAddress :exec
DELETE FROM addresses
WHERE id = $1
`

func (q *Queries) DeleteAddress(ctx context.Context, id pgtype.UUID) error {
	_, err := q.db.Exec(ctx, deleteAddress, id)
	return err
}

const deleteAddressForUser = `-- name: DeleteAddressForUser :exec
DELETE FROM addresses
WHERE id = $1 AND user_id = $2
`

type DeleteAddressForUserParams struct {
	ID     pgtype.UUID `json:"id"`
	UserID pgtype.UUID `json:"user_id"`
}

func (q *Queries) DeleteAddressForUser(ctx context.Context, arg DeleteAddressForUserParams) error {
	_, err := q.db.Exec(ctx, deleteAddressForUser, arg.ID, arg.UserID)
	return err
}

const deleteAddressesByUserID = `-- name: DeleteAddressesByUserID :exec
DELETE FROM addresses
WHERE user_id = $1
`

func (q *Queries) DeleteAddressesByUserID(ctx context.Context, userID pgtype.UUID) error {
	_, err := q.db.Exec(ctx, deleteAddressesByUserID, userID)
	return err
}

const getAddressByID = `-- name: GetAddressByID :one
SELECT id, user_id, address, floor, unit_no, block_tower, company_name, created_at, updated_at FROM addresses
WHERE id = $1 LIMIT 1
`

func (q *Queries) GetAddressByID(ctx context.Context, id pgtype.UUID) (Address, error) {
	row := q.db.QueryRow(ctx, getAddressByID, id)
	var i Address
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Address,
		&i.Floor,
		&i.UnitNo,
		&i.BlockTower,
		&i.CompanyName,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getAddressByIDAndUserID = `-- name: GetAddressByIDAndUserID :one
SELECT id, user_id, address, floor, unit_no, block_tower, company_name, created_at, updated_at FROM addresses
WHERE id = $1 AND user_id = $2 LIMIT 1
`

type GetAddressByIDAndUserIDParams struct {
	ID     pgtype.UUID `json:"id"`
	UserID pgtype.UUID `json:"user_id"`
}

func (q *Queries) GetAddressByIDAndUserID(ctx context.Context, arg GetAddressByIDAndUserIDParams) (Address, error) {
	row := q.db.QueryRow(ctx, getAddressByIDAndUserID, arg.ID, arg.UserID)
	var i Address
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Address,
		&i.Floor,
		&i.UnitNo,
		&i.BlockTower,
		&i.CompanyName,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getAddressesByUserID = `-- name: GetAddressesByUserID :many
SELECT id, user_id, address, floor, unit_no, block_tower, company_name, created_at, updated_at FROM addresses
WHERE user_id = $1
ORDER BY created_at DESC
`

func (q *Queries) GetAddressesByUserID(ctx context.Context, userID pgtype.UUID) ([]Address, error) {
	rows, err := q.db.Query(ctx, getAddressesByUserID, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Address{}
	for rows.Next() {
		var i Address
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.Address,
			&i.Floor,
			&i.UnitNo,
			&i.BlockTower,
			&i.CompanyName,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUserWithDefaultAddress = `-- name: GetUserWithDefaultAddress :one
SELECT 
    u.id, u.email, u.username, u.password_hash, u.first_name, u.last_name, u.created_at, u.updated_at, u.default_address_id,
    a.id as default_address_id,
    a.address as default_address,
    a.floor as default_floor,
    a.unit_no as default_unit_no,
    a.block_tower as default_block_tower,
    a.company_name as default_company_name
FROM users u
LEFT JOIN addresses a ON u.default_address_id = a.id
WHERE u.id = $1
LIMIT 1
`

type GetUserWithDefaultAddressRow struct {
	ID                 pgtype.UUID        `json:"id"`
	Email              string             `json:"email"`
	Username           string             `json:"username"`
	PasswordHash       string             `json:"password_hash"`
	FirstName          pgtype.Text        `json:"first_name"`
	LastName           pgtype.Text        `json:"last_name"`
	CreatedAt          pgtype.Timestamptz `json:"created_at"`
	UpdatedAt          pgtype.Timestamptz `json:"updated_at"`
	DefaultAddressID   pgtype.UUID        `json:"default_address_id"`
	DefaultAddressID_2 pgtype.UUID        `json:"default_address_id_2"`
	DefaultAddress     pgtype.Text        `json:"default_address"`
	DefaultFloor       pgtype.Text        `json:"default_floor"`
	DefaultUnitNo      pgtype.Text        `json:"default_unit_no"`
	DefaultBlockTower  pgtype.Text        `json:"default_block_tower"`
	DefaultCompanyName pgtype.Text        `json:"default_company_name"`
}

func (q *Queries) GetUserWithDefaultAddress(ctx context.Context, id pgtype.UUID) (GetUserWithDefaultAddressRow, error) {
	row := q.db.QueryRow(ctx, getUserWithDefaultAddress, id)
	var i GetUserWithDefaultAddressRow
	err := row.Scan(
		&i.ID,
		&i.Email,
		&i.Username,
		&i.PasswordHash,
		&i.FirstName,
		&i.LastName,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DefaultAddressID,
		&i.DefaultAddressID_2,
		&i.DefaultAddress,
		&i.DefaultFloor,
		&i.DefaultUnitNo,
		&i.DefaultBlockTower,
		&i.DefaultCompanyName,
	)
	return i, err
}

const listAllAddresses = `-- name: ListAllAddresses :many
SELECT id, user_id, address, floor, unit_no, block_tower, company_name, created_at, updated_at FROM addresses
ORDER BY created_at DESC
LIMIT $1 OFFSET $2
`

type ListAllAddressesParams struct {
	Limit  int32 `json:"limit"`
	Offset int32 `json:"offset"`
}

func (q *Queries) ListAllAddresses(ctx context.Context, arg ListAllAddressesParams) ([]Address, error) {
	rows, err := q.db.Query(ctx, listAllAddresses, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Address{}
	for rows.Next() {
		var i Address
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.Address,
			&i.Floor,
			&i.UnitNo,
			&i.BlockTower,
			&i.CompanyName,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const setDefaultAddress = `-- name: SetDefaultAddress :one
UPDATE users
SET default_address_id = $2
WHERE id = $1
RETURNING id, email, username, password_hash, first_name, last_name, created_at, updated_at, default_address_id
`

type SetDefaultAddressParams struct {
	ID               pgtype.UUID `json:"id"`
	DefaultAddressID pgtype.UUID `json:"default_address_id"`
}

func (q *Queries) SetDefaultAddress(ctx context.Context, arg SetDefaultAddressParams) (User, error) {
	row := q.db.QueryRow(ctx, setDefaultAddress, arg.ID, arg.DefaultAddressID)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Email,
		&i.Username,
		&i.PasswordHash,
		&i.FirstName,
		&i.LastName,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DefaultAddressID,
	)
	return i, err
}

const setDefaultAddressForUser = `-- name: SetDefaultAddressForUser :one
UPDATE users u
SET default_address_id = $2
WHERE u.id = $1
AND EXISTS (
    SELECT 1 FROM addresses a 
    WHERE a.id = $2 AND a.user_id = $1
)
RETURNING u.id, u.email, u.username, u.password_hash, u.first_name, u.last_name, u.created_at, u.updated_at, u.default_address_id
`

type SetDefaultAddressForUserParams struct {
	ID               pgtype.UUID `json:"id"`
	DefaultAddressID pgtype.UUID `json:"default_address_id"`
}

func (q *Queries) SetDefaultAddressForUser(ctx context.Context, arg SetDefaultAddressForUserParams) (User, error) {
	row := q.db.QueryRow(ctx, setDefaultAddressForUser, arg.ID, arg.DefaultAddressID)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Email,
		&i.Username,
		&i.PasswordHash,
		&i.FirstName,
		&i.LastName,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DefaultAddressID,
	)
	return i, err
}

const updateAddress = `-- name: UpdateAddress :one
UPDATE addresses
SET
    address = COALESCE($1, address),
    floor = COALESCE($2, floor),
    unit_no = COALESCE($3, unit_no),
    block_tower = COALESCE($4, block_tower),
    company_name = COALESCE($5, company_name),
    updated_at = CURRENT_TIMESTAMP
WHERE id = $6
RETURNING id, user_id, address, floor, unit_no, block_tower, company_name, created_at, updated_at
`

type UpdateAddressParams struct {
	Address     pgtype.Text `json:"address"`
	Floor       pgtype.Text `json:"floor"`
	UnitNo      pgtype.Text `json:"unit_no"`
	BlockTower  pgtype.Text `json:"block_tower"`
	CompanyName pgtype.Text `json:"company_name"`
	ID          pgtype.UUID `json:"id"`
}

func (q *Queries) UpdateAddress(ctx context.Context, arg UpdateAddressParams) (Address, error) {
	row := q.db.QueryRow(ctx, updateAddress,
		arg.Address,
		arg.Floor,
		arg.UnitNo,
		arg.BlockTower,
		arg.CompanyName,
		arg.ID,
	)
	var i Address
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Address,
		&i.Floor,
		&i.UnitNo,
		&i.BlockTower,
		&i.CompanyName,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const updateAddressForUser = `-- name: UpdateAddressForUser :one
UPDATE addresses
SET
    address = COALESCE($1, address),
    floor = COALESCE($2, floor),
    unit_no = COALESCE($3, unit_no),
    block_tower = COALESCE($4, block_tower),
    company_name = COALESCE($5, company_name),
    updated_at = CURRENT_TIMESTAMP
WHERE id = $6 AND user_id = $7
RETURNING id, user_id, address, floor, unit_no, block_tower, company_name, created_at, updated_at
`

type UpdateAddressForUserParams struct {
	Address     pgtype.Text `json:"address"`
	Floor       pgtype.Text `json:"floor"`
	UnitNo      pgtype.Text `json:"unit_no"`
	BlockTower  pgtype.Text `json:"block_tower"`
	CompanyName pgtype.Text `json:"company_name"`
	ID          pgtype.UUID `json:"id"`
	UserID      pgtype.UUID `json:"user_id"`
}

func (q *Queries) UpdateAddressForUser(ctx context.Context, arg UpdateAddressForUserParams) (Address, error) {
	row := q.db.QueryRow(ctx, updateAddressForUser,
		arg.Address,
		arg.Floor,
		arg.UnitNo,
		arg.BlockTower,
		arg.CompanyName,
		arg.ID,
		arg.UserID,
	)
	var i Address
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Address,
		&i.Floor,
		&i.UnitNo,
		&i.BlockTower,
		&i.CompanyName,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}
