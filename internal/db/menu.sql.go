// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: menu.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const createMenuItem = `-- name: CreateMenuItem :one
INSERT INTO menu_items (parent_id, code, label, icon, path, permission_id, order_index)
VALUES ($1, $2, $3, $4, $5, $6, $7)
RETURNING id, parent_id, code, label, icon, path, permission_id, order_index, is_active, created_at, updated_at
`

type CreateMenuItemParams struct {
	ParentID     pgtype.UUID `json:"parent_id"`
	Code         string      `json:"code"`
	Label        string      `json:"label"`
	Icon         pgtype.Text `json:"icon"`
	Path         pgtype.Text `json:"path"`
	PermissionID pgtype.UUID `json:"permission_id"`
	OrderIndex   int32       `json:"order_index"`
}

func (q *Queries) CreateMenuItem(ctx context.Context, arg CreateMenuItemParams) (MenuItem, error) {
	row := q.db.QueryRow(ctx, createMenuItem,
		arg.ParentID,
		arg.Code,
		arg.Label,
		arg.Icon,
		arg.Path,
		arg.PermissionID,
		arg.OrderIndex,
	)
	var i MenuItem
	err := row.Scan(
		&i.ID,
		&i.ParentID,
		&i.Code,
		&i.Label,
		&i.Icon,
		&i.Path,
		&i.PermissionID,
		&i.OrderIndex,
		&i.IsActive,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const deleteMenuItem = `-- name: DeleteMenuItem :exec
DELETE FROM menu_items WHERE id = $1
`

func (q *Queries) DeleteMenuItem(ctx context.Context, id pgtype.UUID) error {
	_, err := q.db.Exec(ctx, deleteMenuItem, id)
	return err
}

const getAllMenuItems = `-- name: GetAllMenuItems :many
SELECT id, parent_id, code, label, icon, path, permission_id, order_index, is_active, created_at, updated_at FROM menu_items
WHERE is_active = true
ORDER BY order_index
`

func (q *Queries) GetAllMenuItems(ctx context.Context) ([]MenuItem, error) {
	rows, err := q.db.Query(ctx, getAllMenuItems)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []MenuItem{}
	for rows.Next() {
		var i MenuItem
		if err := rows.Scan(
			&i.ID,
			&i.ParentID,
			&i.Code,
			&i.Label,
			&i.Icon,
			&i.Path,
			&i.PermissionID,
			&i.OrderIndex,
			&i.IsActive,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getChildMenuItems = `-- name: GetChildMenuItems :many
SELECT id, parent_id, code, label, icon, path, permission_id, order_index, is_active, created_at, updated_at FROM menu_items
WHERE parent_id = $1 AND is_active = true
ORDER BY order_index
`

func (q *Queries) GetChildMenuItems(ctx context.Context, parentID pgtype.UUID) ([]MenuItem, error) {
	rows, err := q.db.Query(ctx, getChildMenuItems, parentID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []MenuItem{}
	for rows.Next() {
		var i MenuItem
		if err := rows.Scan(
			&i.ID,
			&i.ParentID,
			&i.Code,
			&i.Label,
			&i.Icon,
			&i.Path,
			&i.PermissionID,
			&i.OrderIndex,
			&i.IsActive,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getMenuItemByCode = `-- name: GetMenuItemByCode :one
SELECT id, parent_id, code, label, icon, path, permission_id, order_index, is_active, created_at, updated_at FROM menu_items
WHERE code = $1 AND is_active = true
`

func (q *Queries) GetMenuItemByCode(ctx context.Context, code string) (MenuItem, error) {
	row := q.db.QueryRow(ctx, getMenuItemByCode, code)
	var i MenuItem
	err := row.Scan(
		&i.ID,
		&i.ParentID,
		&i.Code,
		&i.Label,
		&i.Icon,
		&i.Path,
		&i.PermissionID,
		&i.OrderIndex,
		&i.IsActive,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getMenuItemByID = `-- name: GetMenuItemByID :one
SELECT id, parent_id, code, label, icon, path, permission_id, order_index, is_active, created_at, updated_at FROM menu_items
WHERE id = $1 AND is_active = true
`

func (q *Queries) GetMenuItemByID(ctx context.Context, id pgtype.UUID) (MenuItem, error) {
	row := q.db.QueryRow(ctx, getMenuItemByID, id)
	var i MenuItem
	err := row.Scan(
		&i.ID,
		&i.ParentID,
		&i.Code,
		&i.Label,
		&i.Icon,
		&i.Path,
		&i.PermissionID,
		&i.OrderIndex,
		&i.IsActive,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getMenuItemsByRole = `-- name: GetMenuItemsByRole :many
WITH RECURSIVE menu_tree AS (
    -- Get root menu items (no parent)
    SELECT 
        mi.id,
        mi.parent_id,
        mi.code,
        mi.label,
        mi.icon,
        mi.path,
        mi.permission_id,
        mi.order_index,
        0 as depth
    FROM menu_items mi
    WHERE mi.parent_id IS NULL 
      AND mi.is_active = true
      AND (
          mi.permission_id IS NULL 
          OR mi.permission_id IN (
              SELECT rp.permission_id 
              FROM role_permissions rp 
              WHERE rp.role = $1
          )
      )
    
    UNION ALL
    
    -- Get child menu items recursively
    SELECT 
        mi.id,
        mi.parent_id,
        mi.code,
        mi.label,
        mi.icon,
        mi.path,
        mi.permission_id,
        mi.order_index,
        mt.depth + 1
    FROM menu_items mi
    INNER JOIN menu_tree mt ON mi.parent_id = mt.id
    WHERE mi.is_active = true
      AND (
          mi.permission_id IS NULL 
          OR mi.permission_id IN (
              SELECT rp.permission_id 
              FROM role_permissions rp 
              WHERE rp.role = $1
          )
      )
)
SELECT id, parent_id, code, label, icon, path, permission_id, order_index, depth FROM menu_tree
ORDER BY depth, order_index
`

type GetMenuItemsByRoleRow struct {
	ID           pgtype.UUID `json:"id"`
	ParentID     pgtype.UUID `json:"parent_id"`
	Code         string      `json:"code"`
	Label        string      `json:"label"`
	Icon         pgtype.Text `json:"icon"`
	Path         pgtype.Text `json:"path"`
	PermissionID pgtype.UUID `json:"permission_id"`
	OrderIndex   int32       `json:"order_index"`
	Depth        int32       `json:"depth"`
}

func (q *Queries) GetMenuItemsByRole(ctx context.Context, role string) ([]GetMenuItemsByRoleRow, error) {
	rows, err := q.db.Query(ctx, getMenuItemsByRole, role)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetMenuItemsByRoleRow{}
	for rows.Next() {
		var i GetMenuItemsByRoleRow
		if err := rows.Scan(
			&i.ID,
			&i.ParentID,
			&i.Code,
			&i.Label,
			&i.Icon,
			&i.Path,
			&i.PermissionID,
			&i.OrderIndex,
			&i.Depth,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateMenuItem = `-- name: UpdateMenuItem :one
UPDATE menu_items
SET label = COALESCE($2, label),
    icon = COALESCE($3, icon),
    path = COALESCE($4, path),
    permission_id = COALESCE($5, permission_id),
    order_index = COALESCE($6, order_index),
    is_active = COALESCE($7, is_active)
WHERE id = $1
RETURNING id, parent_id, code, label, icon, path, permission_id, order_index, is_active, created_at, updated_at
`

type UpdateMenuItemParams struct {
	ID           pgtype.UUID `json:"id"`
	Label        pgtype.Text `json:"label"`
	Icon         pgtype.Text `json:"icon"`
	Path         pgtype.Text `json:"path"`
	PermissionID pgtype.UUID `json:"permission_id"`
	OrderIndex   pgtype.Int4 `json:"order_index"`
	IsActive     pgtype.Bool `json:"is_active"`
}

func (q *Queries) UpdateMenuItem(ctx context.Context, arg UpdateMenuItemParams) (MenuItem, error) {
	row := q.db.QueryRow(ctx, updateMenuItem,
		arg.ID,
		arg.Label,
		arg.Icon,
		arg.Path,
		arg.PermissionID,
		arg.OrderIndex,
		arg.IsActive,
	)
	var i MenuItem
	err := row.Scan(
		&i.ID,
		&i.ParentID,
		&i.Code,
		&i.Label,
		&i.Icon,
		&i.Path,
		&i.PermissionID,
		&i.OrderIndex,
		&i.IsActive,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}
